# 第五章 网络数据与网络错误

## 1 字节与字符串

### 了解 ASCII 表的基本内容

- 0,1,2 对应的十六进制数分别是 30,31,32
- A,B,C 对应的十六进制数分别是 41,42,43
- a,b,c 对应的十六进制数分别是 61,62,63
- 空格对应的十六进制数是 20
- 换行符对应的十六进制数是 0A
- 回车符对应的十六进制数是 0D

### 了解单字节编码与多字节编码的基本含义

- 单字节编码：每个字符占用一个字节
- 多字节编码：每个字符占用多个字节
- 例如：UTF-8 编码中，英文字符占用一个字节，中文字符占用三个字节
- 例如：UTF-16 编码中，英文字符占用两个字节，中文字符占用两个字节
- 例如：UTF-32 编码中，英文字符占用四个字节，中文字符占用四个字节
- 例如：GBK 编码中，英文字符占用一个字节，中文字符占用两个字节
- 例如：GB2312 编码中，英文字符占用一个字节，中文字符占用两个字节
- 例如：BIG5 编码中，英文字符占用一个字节，中文字符占用两个字节
- 例如：ASCII 编码中，英文字符占用一个字节，中文字符无法编码

### 理解大端法和小端法的含义，能分辨甚至写出一个数字的大端表示形式和小端表示形式

- 大端法：高位字节存放在内存的低地址端，低位字节存放在内存的高地址端
- 小端法：低位字节存放在内存的低地址端，高位字节存放在内存的高地址端
- 例如：十六进制数 0x12345678
  - 大端法表示形式：12 34 56 78
  - 小端法表示形式：78 56 34 12
- 例如：十六进制数 0x1234
  - 大端法表示形式：12 34
  - 小端法表示形式：34 12
- 例如：十六进制数 0x12
  - 大端法表示形式：12
  - 小端法表示形式：12
- 例如：十六进制数 0x1
  - 大端法表示形式：01
  - 小端法表示形式：01
- 例如：十六进制数 0x0
  - 大端法表示形式：00
  - 小端法表示形式：00
- 例如：十六进制数 0x123456789ABCDEF
  - 大端法表示形式：12 34 56 78 9A BC DE F
  - 小端法表示形式：F E D C B A 9 78 56 34 12
- 例如：十六进制数 0x123456789ABCDEF0
  - 大端法表示形式：12 34 56 78 9A BC DE F0
  - 小端法表示形式：F0 E D C B A 9 78 56 34 12
  - 注意：这里的 F0 是一个字节，而不是两个字节
- 例如：十六进制数 0x123456789ABCDEF00
  - 大端法表示形式：12 34 56 78 9A BC DE F0 0
  - 小端法表示形式：0 F0 E D C B A 9 78 56 34 12
  - 注意：这里的 F0 0 是两个字节，而不是一个字节
  - 注意：这里的 0 F0 是两个字节，而不是一个字节

### 掌握字符串类型和字节类型的相互转换方法

- 字符串转字节：`str.encode()`
- 字节转字符串：`bytes.decode()`
- 例如：`b'hello'.decode()`，结果是`'hello'`
- 例如：`'hello'.encode()`，结果是`b'hello'`
- 例如：`'你好'.encode()`，结果是`b'\xe4\xbd\xa0\xe5\xa5\xbd'`
- 例如：`b'\xe4\xbd\xa0\xe5\xa5\xbd'.decode()`，结果是`'你好'`
- 例如：`b'\xe4\xbd\xa0\xe5\xa5\xbd'.decode('gbk')`，结果是`'浣犲ソ'`
- 例如：`b'\xe4\xbd\xa0\xe5\xa5\xbd'.decode('gb2312')`，结果是`'浣犲ソ'`
- 例如：`b'\xe4\xbd\xa0\xe5\xa5\xbd'.decode('big5')`，结果是`'妤煎ソ'`
- 例如：`b'\xe4\xbd\xa0\xe5\xa5\xbd'.decode('utf-8')`，结果是`'你好'`

### 了解 x86 架构默认使用小端法，ARM 架构默认使用大端法

- x86 架构默认使用小端法
  - 原因：因为 x86 架构是 Intel 公司设计的，而 Intel 公司的 CPU 默认使用小端法
  - 例如：`0x12345678`在 x86 架构中的表示形式是`78 56 34 12`
  - 例如：`0x1234`在 x86 架构中的表示形式是`34 12`
  - 例如：`0x12`在 x86 架构中的表示形式是`12`
  - 例如：`0x1`在 x86 架构中的表示形式是`01`
  - 例如：`0x0`在 x86 架构中的表示形式是`00`
  - 例如：`0x123456789ABCDEF`在 x86 架构中的表示形式是`EF CD AB 89 67 45 23 01`
- ARM 架构默认使用大端法
  - 原因：因为 ARM 架构是 ARM 公司设计的，而 ARM 公司的 CPU 默认使用大端法
  - 例如：`0x12345678`在 ARM 架构中的表示形式是`12 34 56 78`
  - 例如：`0x1234`在 ARM 架构中的表示形式是`12 34`
  - 例如：`0x12`在 ARM 架构中的表示形式是`12`
  - 例如：`0x1`在 ARM 架构中的表示形式是`01`
  - 例如：`0x0`在 ARM 架构中的表示形式是`00`
  - 例如：`0x123456789ABCDEF`在 ARM 架构中的表示形式是`01 23 45 67 89 AB CD EF`

### 理解针对网络套接字传输二进制数据时的 3 条建议

1. 建议一：使用 struct 模块生成用于网络传输的二进制数据，接收方使用 struct 模块解析二进制数据
2. 建议二：如果要自己控制网络传输的数据格式的话，在选择网络字节顺序的时候使用！前缀
3. 建议三：如果其他人设计了协议并使用小端法，那么就使用小端法，必须使用<前缀

### 掌握 struct 模块的使用方法

- `struct.pack(fmt, v1, v2, ...)`：将多个值按照指定的格式转换为二进制数据
- `struct.unpack(fmt, data)`：将二进制数据按照指定的格式转换为多个值
- `struct.calcsize(fmt)`：计算指定格式的二进制数据的长度
- 例如：`struct.pack('hhl', 1, 2, 3)`，结果是`b'\x01\x00\x02\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00'`
- 例如：`struct.unpack('hhl', b'\x01\x00\x02\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00')`，结果是`(1, 2, 3)`
- 例如：`struct.calcsize('hhl')`，结果是`8`

## 2 封帧与引用

在计算机网络中，封帧（Frame encapsulation）是一种数据封装的过程，它涉及将数据包装在协议的特定格式中，以便于在网络中传输。封帧确保数据以可识别和可管理的形式在网络层间移动。以下是几种主流的封帧方法：

1. **字符计数（Character Count）**：

   - 在这种方法中，帧的开始是一个特殊的字节或一组字节，它表示帧中数据字节的数量。
   - 缺点是如果计数信息出错，那么帧边界将会丢失，导致同步问题。

2. **字节填充（Byte Stuffing）或字符填充**：

   - 在这种方法中，特殊字节（如 `DLE` 在 ASCII 中）用于标记帧的开始和结束。
   - 如果这些特殊字节自然出现在数据中，将采用字节填充技术来区分数据和控制信息。

3. **比特填充（Bit Stuffing）**：

   - 比特填充是一种更为通用的封帧方法，尤其是在位级协议中，如 HDLC（高级数据链路控制）。
   - 帧以特殊的位模式开始和结束，如“01111110”。如果这个模式在数据中出现，将插入额外的位以防止混淆。

4. **违规编码（Violating Encoding）**：

   - 这种方法使用在物理层不允许的编码模式来表示帧的开始和结束。
   - 它通常用于那些使用曼彻斯特编码或 4B/5B 编码等编码方案的网络。

5. **使用首部和尾部标志（Flag bytes with header and trailer）**：
   - 在这种方法中，每个帧都有一个头部和尾部，通常包含特殊的标志字节，地址信息，控制信息，以及一个或多个校验位（如循环冗余检查 CRC）来检测错误。

这些封帧方法中的每一种都有其优缺点，并且它们的选择通常取决于网络协议和物理介质的特性。例如，字符填充适合于字符导向的协议，而比特填充则更适用于位导向的协议。封帧确保数据能够有效地在网络设备之间传输，同时提供错误检测和纠正的机制。

### 掌握几种主流的封帧方法

封帧是数据链路层的一个重要功能，它涉及将网络层的数据包封装成帧，以便在物理层进行传输。下面是几种主流的封帧方式，以及它们的特点和细节：

1. **定长消息（Fixed Size Framing）**：

   - 在这种方式中，每个帧的大小是固定的。
   - 优点是实现简单，处理起来也较为高效。
   - 缺点是可能会造成带宽的浪费，因为不是所有的数据包都能刚好填满一个帧。

2. **特殊字符（Sentinel Characters）**：

   - 使用特定的字符序列来标识帧的开始和结束，例如 ASCII 控制字符。
   - 常见的特殊字符包括帧开始标志（Frame Start）和帧结束标志（Frame End）。
   - 这种方法的挑战在于需要处理数据中出现的特殊字符，通常通过字节填充（Byte Stuffing）或位填充（Bit Stuffing）来解决。

3. **长度前缀（Length-Prefixed Framing）**：
   - 在帧的开始部分加入一个字段来指明帧的长度。
   - 这种方式可以有两种形式：
     - **文本形式的长度前缀**：长度值以文本（例如 ASCII 字符）形式表示。这种方法易于阅读和调试，但效率较低。
     - **二进制形式的长度前缀**：长度值以二进制形式表示。这种方法效率更高，但不如文本形式直观。

这些封帧方法中的每一种都有其适用场景和优缺点。定长消息适合于数据量稳定的场景，特殊字符法适合于文本数据传输，而长度前缀法则在需要处理不同大小数据包的场景中非常有效。封帧的选择取决于数据的特性、网络环境和性能要求。

### 理解 HTTP 使用的几种封帧技术

HTTP（超文本传输协议）是一种应用层协议，主要用于在 Web 应用中传输数据。尽管 HTTP 本身不直接实现封帧技术，因为这是更低网络层（如 TCP/IP）的职责，但 HTTP/1.1 和 HTTP/2 有着不同的数据封装和传输机制，这些机制在某种程度上类似于封帧技术。下面是 HTTP 在这两个版本中使用的几种“封帧”技术：

1. **HTTP/1.1**：

   - **非持久连接（Non-Persistent Connections）**：每个 HTTP 请求/响应对都会打开一个新的 TCP 连接，完成后即关闭。这种方式效率低下，因为频繁地建立和关闭连接会消耗大量资源和时间。
   - **持久连接（Persistent Connections）**：在 HTTP/1.1 中，默认使用持久连接，一个 TCP 连接可以传输多个 HTTP 请求和响应。这种方式减少了连接的建立和关闭次数，提高了效率。

2. **HTTP/2**：
   - **二进制帧（Binary Framing Layer）**：在 HTTP/2 中，引入了二进制帧的概念。HTTP/2 将所有传输的信息分割为更小的消息和帧，并对它们采用二进制编码。
   - **流（Streams）**：HTTP/2 通过在一个单一的 TCP 连接上使用多个流（Streams）来允许多个请求和响应同时进行。每个流都由一系列的帧组成，这些帧可以属于不同的消息。
   - **头部压缩（Header Compression）**：HTTP/2 采用专门的算法（如 HPACK）压缩请求和响应的头部，减少了传输的数据量。
   - **服务器推送（Server Push）**：服务器可以主动向客户端发送资源，而不必等待客户端的明确请求，这可以进一步提高页面加载效率。

总的来说，HTTP/1.1 主要依赖于文本基础的消息格式和持久连接来提高效率，而 HTTP/2 引入了二进制帧、多路复用和头部压缩等技术，大大提高了数据传输的效率和性能。

## 3 pickle 与 自定义界符的格式

### 掌握 pickle 中的封帧方法

`pickle` 是 Python 的一个模块，用于将 Python 对象序列化为字节流，这可以用于文件存储或通过网络传输。在使用 `pickle` 时，封帧方法不同于传统的网络封帧技术，因为它是针对 Python 对象的序列化和反序列化。下面是关于 `pickle` 封帧方法的一些要点：

1. **序列化（Serialization）**：

   - 当使用 `pickle` 对对象进行序列化时，它会将对象转换成一个字节流。这个字节流包含了重建该对象所需的所有信息。

2. **反序列化（Deserialization）**：

   - 反序列化是序列化的逆过程。它将 `pickle` 生成的字节流转换回原来的 Python 对象。

3. **封帧机制**：

   - `pickle` 使用的封帧机制是内置的，它自动处理所需的所有细节，以确保字节流可以被正确地序列化和反序列化。
   - 序列化的数据包含了对象类型、结构和内容的信息。`pickle` 会保存足够的元数据，以确保反序列化时能够准确地重建对象。

4. **安全性**：

   - 需要注意的是，从不受信任的源反序列化数据可能是不安全的。`pickle` 不是加密或压缩的形式，因此它序列化的数据应该只在受信任的内部使用。

5. **使用场景**：
   - `pickle` 主要用于 Python 对象的持久化存储或在信任的环境中的 Python 对象传输。

在实际应用中，如果需要通过网络发送 `pickle` 序列化的数据，可能需要在更低的网络层（如 TCP）上实现适当的封帧技术，以确保数据的完整性和正确分界。例如，可以在发送 `pickle` 数据前添加长度前缀，或者在数据的开始和结束处添加特定的界符。这样的处理确保了接收方能够正确地从网络流中提取和反序列化 `pickle` 数据。

## 4 XML 与 JSON

### 了解 XML 与 JSON 的基本特点与适用领域

XML（可扩展标记语言）和 JSON（JavaScript 对象表示法）都是常用的数据交换格式，但它们在结构、语法和使用场景上有一些显著的不同。让我们来看看它们各自的特点和适用领域。

### XML 的特点和适用领域：

1. **特点**：

   - XML 是一种标记语言，非常适合复杂的文档结构，如带有多层嵌套和属性的数据。
   - 它是自描述性的，意味着标签通常描述了数据的内容。
   - 支持命名空间，适合在多种不同类型的数据需要集成在一起的情况下使用。
   - 可以通过 XSD（XML Schema Definition）定义严格的结构，也支持通过 XSLT（Extensible Stylesheet Language Transformations）进行转换。

2. **适用领域**：
   - 由于其复杂的文档处理能力，XML 常用于企业级应用，如 Web 服务和配置文件。
   - 在需要长期数据存储和文档可读性的场合，XML 是一个不错的选择。
   - 在需要强数据验证和结构定义的系统中，如电子政务和银行系统。

### JSON 的特点和适用领域：

1. **特点**：

   - JSON 是一种轻量级的数据交换格式，以易于阅读和编写的方式呈现数据，同时也易于机器解析和生成。
   - 它基于 JavaScript 的对象和数组，结构清晰简单。
   - 不支持注释，结构比 XML 简单，一般不用于表示复杂的层次数据结构。
   - 传输效率高，尤其是在网络传输中，由于格式简单，解析速度快。

2. **适用领域**：
   - JSON 非常适合 Web 应用程序，特别是在使用 JavaScript 的前端框架和库时。
   - 由于其轻量级特性，它是移动应用和微服务架构的理想选择。
   - 在需要快速交互和数据更新的实时应用程序中，如在线游戏和聊天应用。

总的来说，XML 适合于需要严格文档结构和扩展性的复杂应用，而 JSON 则在需要高效数据交换和简单结构的现代网络应用中更受欢迎。选择哪种格式取决于具体的应用需求和上下文环境。

## 5 压缩

理解“数据在网络中传输所需要的时间通常远远多于 CPU 准备数据所用的时间”,结合带宽的发展速度和 CPU 的发展速度来思考

您提到的这个观点是指在网络通信中，数据传输的时间通常比 CPU 处理（准备）数据的时间要长得多。这个现象在很大程度上受到带宽和 CPU 处理能力的发展速度的影响。以下是对这两个因素及其发展趋势的分析：

### 带宽的发展速度

1. **历史趋势**：过去几十年里，网络带宽经历了显著的增长，特别是从拨号上网到宽带互联网，再到现在的高速光纤和 5G 网络。
2. **局限性**：尽管带宽有了显著的提升，但它的增长速度相比于 CPU 处理能力的提升还是慢了很多。此外，带宽的增长还受到物理和经济因素的限制，如线路铺设成本和技术的可行性。

### CPU 的发展速度

1. **摩尔定律**：CPU 的发展遵循摩尔定律，大致意味着每两年处理能力翻一番。这导致了 CPU 处理速度的极大提升。
2. **技术革新**：近年来，除了传统的性能提升外，CPU 的发展还包括多核处理、并行计算和专用处理单元（如 GPU），这进一步提高了数据处理的效率。

### 结合考虑

- **网络延迟 vs. 处理时间**：由于 CPU 的快速发展，数据的处理时间（如压缩、加密）变得越来越短，而数据在网络中的传输时间仍然是影响通信效率的主要因素。即便是在高带宽网络中，传输大量数据（如视频流）也会产生不小的延迟。
- **压缩的重要性**：在这种情况下，数据压缩变得尤为重要。压缩可以显著减少需要传输的数据量，从而减少网络传输时间，尽管这增加了 CPU 的工作负担。但鉴于 CPU 处理速度的快速提升，这个额外的负担通常是可以接受的。
- **优化策略**：在设计网络应用时，优化策略往往需要根据具体情况来决定。例如，在带宽较低的环境中，更强的数据压缩可能更有利；而在高速网络环境下，可以采取较少的压缩来减少 CPU 的负担。

总的来说，由于带宽的增长速度通常落后于 CPU 处理能力的增长速度，因此在网络通信中采取适当的数据压缩策略以减少传输时间是一种有效的优化方法。随着技术的不断进步，这种平衡可能会有所变化，但目前看来，数据压缩仍然是一个重要的考虑因素。

### 理解代码

```python
#!/usr/bin/env python3
# Foundations of Python Network Programming, Third Edition
# https://github.com/brandon-rhodes/fopnp/blob/m/py3/chapter05/blocks.py
# Sending data over a stream but delimited as length-prefixed blocks.

import socket, struct
from argparse import ArgumentParser

header_struct = struct.Struct('!I')  # messages up to 2**32 - 1 in length

def recvall(sock, length):
    blocks = []
    while length:
        block = sock.recv(length)
        if not block:
            raise EOFError('socket closed with {} bytes left'
                           ' in this block'.format(length))
        length -= len(block)
        blocks.append(block)
    return b''.join(blocks)

def get_block(sock):
    data = recvall(sock, header_struct.size)
    (block_length,) = header_struct.unpack(data)
    return recvall(sock, block_length)

def put_block(sock, message):
    block_length = len(message)
    sock.send(header_struct.pack(block_length))
    sock.send(message)

def server(address):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind(address)
    sock.listen(1)
    print('Run this script in another window with "-c" to connect')
    print('Listening at', sock.getsockname())
    sc, sockname = sock.accept()
    print('Accepted connection from', sockname)
    sc.shutdown(socket.SHUT_WR)
    while True:
        block = get_block(sc)
        if not block:
            break
        print('Block says:', repr(block))
    sc.close()
    sock.close()

def client(address):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect(address)
    sock.shutdown(socket.SHUT_RD)
    put_block(sock, b'Beautiful is better than ugly.')
    put_block(sock, b'Explicit is better than implicit.')
    put_block(sock, b'Simple is better than complex.')
    put_block(sock, b'')
    sock.close()

if __name__ == '__main__':
    parser = ArgumentParser(description='Transmit & receive blocks over TCP')
    parser.add_argument('hostname', nargs='?', default='127.0.0.1',
                        help='IP address or hostname (default: %(default)s)')
    parser.add_argument('-c', action='store_true', help='run as the client')
    parser.add_argument('-p', type=int, metavar='port', default=1060,
                        help='TCP port number (default: %(default)s)')
    args = parser.parse_args()
    function = client if args.c else server
    function((args.hostname, args.p))
```

这段 Python 代码是一个简单的 TCP 服务器和客户端的实现，它们通过 TCP 协议发送和接收数据块。数据块的长度在发送前会被打包并发送出去，接收方在接收数据块时会先接收到数据块的长度，然后根据这个长度来接收数据块。

主要函数的功能如下：

- `recvall(sock, length)`: 从指定的 socket 接收指定长度的数据。如果在接收过程中 socket 关闭，会抛出 EOFError 异常。

- `get_block(sock)`: 从指定的 socket 接收一个数据块。首先接收数据块的长度，然后根据这个长度接收数据块。

- `put_block(sock, message)`: 向指定的 socket 发送一个数据块。首先发送数据块的长度，然后发送数据块。

- `server(address)`: 运行 TCP 服务器。服务器会在指定的地址上监听连接，当接收到连接后，会接收并打印出所有接收到的数据块。

- `client(address)`: 运行 TCP 客户端。客户端会连接到指定的服务器，并发送四个数据块。

在`if __name__ == '__main__':`部分，代码解析命令行参数，并根据参数决定运行服务器还是客户端。如果指定了`-c`参数，代码会运行客户端，否则会运行服务器。

## 6 网络异常

### 了解几种主要的异常错误

1. **连接异常（ConnectionError）**：

   - 这是当网络连接出现问题时抛出的异常，例如无法连接到服务器或连接意外断开。

2. **超时异常（TimeoutError）**：

   - 当网络操作超过设定的时间限制时抛出。这在网络延迟或服务器响应缓慢的情况下常见。

3. **地址异常（AddressError）**：

   - 当提供了无效的网络地址（如错误的 IP 地址或域名）时抛出。

4. **协议异常（ProtocolError）**：

   - 当遵循特定网络协议（如 HTTP 或 FTP）的规则出现问题时抛出。

5. **数据传输异常（DataError）**：
   - 在数据传输过程中，如果接收到的数据格式错误或损坏，可能会抛出此类异常。

### 理解在哪种情况下应该抛出更具体的异常

- **特定场景下**：在知道可能发生特定类型的错误时，应该抛出更具体的异常。例如，当你的程序依赖于外部服务器的响应时，可以专门捕获超时异常。
- **提高错误处理的准确性**：具体的异常可以帮助更准确地识别错误的原因，从而提供更有效的错误处理或用户反馈。
- **避免隐藏错误**：使用太过泛化的异常处理（如捕获所有异常）可能会隐藏一些未预见的错误，导致程序行为异常或难以调试。

### 理解 granular 异常处理程序与 blanket 异常处理程序的用法

在网络编程中，处理异常是保证程序稳定运行的关键。理解和识别常见的网络异常，以及何时抛出具体的异常，对于编写健壮的网络应用程序非常重要。下面是一些主要的网络异常错误，以及关于异常处理的最佳实践。

- **精确（Granular）异常处理**：

  - 指的是针对特定的异常类型编写处理代码。
  - 优点是能够提供更精确的错误处理逻辑，缺点是可能需要编写更多的代码来处理各种可能的异常情况。

- **泛化（Blanket）异常处理**：
  - 指的是使用一个通用的异常处理块来捕获所有类型的异常。
  - 优点是减少了代码量，缺点是可能会掩盖某些应该被注意到的问题。

总的来说，选择精确处理还是泛化处理取决于具体的应用场景和对程序稳定性的需求。在关键的功能模块和容错性要求较高的场合，应该使用更精确的异常处理；而在不太关键的地方，或者仅用于日志记录的场合，可以考虑使用泛化异常处理。
