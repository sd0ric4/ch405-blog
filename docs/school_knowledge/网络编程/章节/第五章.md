# 第五章 网络数据与网络错误

## 1 字节与字符串

### 了解 ASCII 表的基本内容

- 0,1,2 对应的十六进制数分别是 30,31,32
- A,B,C 对应的十六进制数分别是 41,42,43
- a,b,c 对应的十六进制数分别是 61,62,63
- 空格对应的十六进制数是 20
- 换行符对应的十六进制数是 0A
- 回车符对应的十六进制数是 0D

### 了解单字节编码与多字节编码的基本含义

- 单字节编码：每个字符占用一个字节
- 多字节编码：每个字符占用多个字节
- 例如：UTF-8 编码中，英文字符占用一个字节，中文字符占用三个字节
- 例如：UTF-16 编码中，英文字符占用两个字节，中文字符占用两个字节
- 例如：UTF-32 编码中，英文字符占用四个字节，中文字符占用四个字节
- 例如：GBK 编码中，英文字符占用一个字节，中文字符占用两个字节
- 例如：GB2312 编码中，英文字符占用一个字节，中文字符占用两个字节
- 例如：BIG5 编码中，英文字符占用一个字节，中文字符占用两个字节
- 例如：ASCII 编码中，英文字符占用一个字节，中文字符无法编码

### 理解大端法和小端法的含义，能分辨甚至写出一个数字的大端表示形式和小端表示形式

- 大端法：高位字节存放在内存的低地址端，低位字节存放在内存的高地址端
- 小端法：低位字节存放在内存的低地址端，高位字节存放在内存的高地址端
- 例如：十六进制数 0x12345678
  - 大端法表示形式：12 34 56 78
  - 小端法表示形式：78 56 34 12
- 例如：十六进制数 0x1234
  - 大端法表示形式：12 34
  - 小端法表示形式：34 12
- 例如：十六进制数 0x12
  - 大端法表示形式：12
  - 小端法表示形式：12
- 例如：十六进制数 0x1
  - 大端法表示形式：01
  - 小端法表示形式：01
- 例如：十六进制数 0x0
  - 大端法表示形式：00
  - 小端法表示形式：00
- 例如：十六进制数 0x123456789ABCDEF
  - 大端法表示形式：12 34 56 78 9A BC DE F
  - 小端法表示形式：F E D C B A 9 78 56 34 12
- 例如：十六进制数 0x123456789ABCDEF0
  - 大端法表示形式：12 34 56 78 9A BC DE F0
  - 小端法表示形式：F0 E D C B A 9 78 56 34 12
  - 注意：这里的 F0 是一个字节，而不是两个字节
- 例如：十六进制数 0x123456789ABCDEF00
  - 大端法表示形式：12 34 56 78 9A BC DE F0 0
  - 小端法表示形式：0 F0 E D C B A 9 78 56 34 12
  - 注意：这里的 F0 0 是两个字节，而不是一个字节
  - 注意：这里的 0 F0 是两个字节，而不是一个字节

### 掌握字符串类型和字节类型的相互转换方法

- 字符串转字节：`str.encode()`
- 字节转字符串：`bytes.decode()`
- 例如：`b'hello'.decode()`，结果是`'hello'`
- 例如：`'hello'.encode()`，结果是`b'hello'`
- 例如：`'你好'.encode()`，结果是`b'\xe4\xbd\xa0\xe5\xa5\xbd'`
- 例如：`b'\xe4\xbd\xa0\xe5\xa5\xbd'.decode()`，结果是`'你好'`
- 例如：`b'\xe4\xbd\xa0\xe5\xa5\xbd'.decode('gbk')`，结果是`'浣犲ソ'`
- 例如：`b'\xe4\xbd\xa0\xe5\xa5\xbd'.decode('gb2312')`，结果是`'浣犲ソ'`
- 例如：`b'\xe4\xbd\xa0\xe5\xa5\xbd'.decode('big5')`，结果是`'妤煎ソ'`
- 例如：`b'\xe4\xbd\xa0\xe5\xa5\xbd'.decode('utf-8')`，结果是`'你好'`

### 了解 x86 架构默认使用小端法，ARM 架构默认使用大端法

- x86 架构默认使用小端法
  - 原因：因为 x86 架构是 Intel 公司设计的，而 Intel 公司的 CPU 默认使用小端法
  - 例如：`0x12345678`在 x86 架构中的表示形式是`78 56 34 12`
  - 例如：`0x1234`在 x86 架构中的表示形式是`34 12`
  - 例如：`0x12`在 x86 架构中的表示形式是`12`
  - 例如：`0x1`在 x86 架构中的表示形式是`01`
  - 例如：`0x0`在 x86 架构中的表示形式是`00`
  - 例如：`0x123456789ABCDEF`在 x86 架构中的表示形式是`EF CD AB 89 67 45 23 01`
- ARM 架构默认使用大端法
  - 原因：因为 ARM 架构是 ARM 公司设计的，而 ARM 公司的 CPU 默认使用大端法
  - 例如：`0x12345678`在 ARM 架构中的表示形式是`12 34 56 78`
  - 例如：`0x1234`在 ARM 架构中的表示形式是`12 34`
  - 例如：`0x12`在 ARM 架构中的表示形式是`12`
  - 例如：`0x1`在 ARM 架构中的表示形式是`01`
  - 例如：`0x0`在 ARM 架构中的表示形式是`00`
  - 例如：`0x123456789ABCDEF`在 ARM 架构中的表示形式是`01 23 45 67 89 AB CD EF`

### 理解针对网络套接字传输二进制数据时的 3 条建议

1. 建议一：使用 struct 模块生成用于网络传输的二进制数据，接收方使用 struct 模块解析二进制数据
2. 建议二：如果要自己控制网络传输的数据格式的话，在选择网络字节顺序的时候使用！前缀
3. 建议三：如果其他人设计了协议并使用小端法，那么就使用小端法，必须使用<前缀

### 掌握 struct 模块的使用方法

- `struct.pack(fmt, v1, v2, ...)`：将多个值按照指定的格式转换为二进制数据
- `struct.unpack(fmt, data)`：将二进制数据按照指定的格式转换为多个值
- `struct.calcsize(fmt)`：计算指定格式的二进制数据的长度
- 例如：`struct.pack('hhl', 1, 2, 3)`，结果是`b'\x01\x00\x02\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00'`
- 例如：`struct.unpack('hhl', b'\x01\x00\x02\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00')`，结果是`(1, 2, 3)`
- 例如：`struct.calcsize('hhl')`，结果是`8`

## 2 封帧与引用

在计算机网络中，封帧（Frame encapsulation）是一种数据封装的过程，它涉及将数据包装在协议的特定格式中，以便于在网络中传输。封帧确保数据以可识别和可管理的形式在网络层间移动。以下是几种主流的封帧方法：

1. **字符计数（Character Count）**：

   - 在这种方法中，帧的开始是一个特殊的字节或一组字节，它表示帧中数据字节的数量。
   - 缺点是如果计数信息出错，那么帧边界将会丢失，导致同步问题。

2. **字节填充（Byte Stuffing）或字符填充**：

   - 在这种方法中，特殊字节（如 `DLE` 在 ASCII 中）用于标记帧的开始和结束。
   - 如果这些特殊字节自然出现在数据中，将采用字节填充技术来区分数据和控制信息。

3. **比特填充（Bit Stuffing）**：

   - 比特填充是一种更为通用的封帧方法，尤其是在位级协议中，如 HDLC（高级数据链路控制）。
   - 帧以特殊的位模式开始和结束，如“01111110”。如果这个模式在数据中出现，将插入额外的位以防止混淆。

4. **违规编码（Violating Encoding）**：

   - 这种方法使用在物理层不允许的编码模式来表示帧的开始和结束。
   - 它通常用于那些使用曼彻斯特编码或 4B/5B 编码等编码方案的网络。

5. **使用首部和尾部标志（Flag bytes with header and trailer）**：
   - 在这种方法中，每个帧都有一个头部和尾部，通常包含特殊的标志字节，地址信息，控制信息，以及一个或多个校验位（如循环冗余检查 CRC）来检测错误。

这些封帧方法中的每一种都有其优缺点，并且它们的选择通常取决于网络协议和物理介质的特性。例如，字符填充适合于字符导向的协议，而比特填充则更适用于位导向的协议。封帧确保数据能够有效地在网络设备之间传输，同时提供错误检测和纠正的机制。

### 掌握几种主流的封帧方法

封帧是数据链路层的一个重要功能，它涉及将网络层的数据包封装成帧，以便在物理层进行传输。下面是几种主流的封帧方式，以及它们的特点和细节：

1. **定长消息（Fixed Size Framing）**：

   - 在这种方式中，每个帧的大小是固定的。
   - 优点是实现简单，处理起来也较为高效。
   - 缺点是可能会造成带宽的浪费，因为不是所有的数据包都能刚好填满一个帧。

2. **特殊字符（Sentinel Characters）**：

   - 使用特定的字符序列来标识帧的开始和结束，例如 ASCII 控制字符。
   - 常见的特殊字符包括帧开始标志（Frame Start）和帧结束标志（Frame End）。
   - 这种方法的挑战在于需要处理数据中出现的特殊字符，通常通过字节填充（Byte Stuffing）或位填充（Bit Stuffing）来解决。

3. **长度前缀（Length-Prefixed Framing）**：
   - 在帧的开始部分加入一个字段来指明帧的长度。
   - 这种方式可以有两种形式：
     - **文本形式的长度前缀**：长度值以文本（例如 ASCII 字符）形式表示。这种方法易于阅读和调试，但效率较低。
     - **二进制形式的长度前缀**：长度值以二进制形式表示。这种方法效率更高，但不如文本形式直观。

这些封帧方法中的每一种都有其适用场景和优缺点。定长消息适合于数据量稳定的场景，特殊字符法适合于文本数据传输，而长度前缀法则在需要处理不同大小数据包的场景中非常有效。封帧的选择取决于数据的特性、网络环境和性能要求。

### 理解 HTTP 使用的几种封帧技术

HTTP（超文本传输协议）是一种应用层协议，主要用于在 Web 应用中传输数据。尽管 HTTP 本身不直接实现封帧技术，因为这是更低网络层（如 TCP/IP）的职责，但 HTTP/1.1 和 HTTP/2 有着不同的数据封装和传输机制，这些机制在某种程度上类似于封帧技术。下面是 HTTP 在这两个版本中使用的几种“封帧”技术：

1. **HTTP/1.1**：

   - **非持久连接（Non-Persistent Connections）**：每个 HTTP 请求/响应对都会打开一个新的 TCP 连接，完成后即关闭。这种方式效率低下，因为频繁地建立和关闭连接会消耗大量资源和时间。
   - **持久连接（Persistent Connections）**：在 HTTP/1.1 中，默认使用持久连接，一个 TCP 连接可以传输多个 HTTP 请求和响应。这种方式减少了连接的建立和关闭次数，提高了效率。

2. **HTTP/2**：
   - **二进制帧（Binary Framing Layer）**：在 HTTP/2 中，引入了二进制帧的概念。HTTP/2 将所有传输的信息分割为更小的消息和帧，并对它们采用二进制编码。
   - **流（Streams）**：HTTP/2 通过在一个单一的 TCP 连接上使用多个流（Streams）来允许多个请求和响应同时进行。每个流都由一系列的帧组成，这些帧可以属于不同的消息。
   - **头部压缩（Header Compression）**：HTTP/2 采用专门的算法（如 HPACK）压缩请求和响应的头部，减少了传输的数据量。
   - **服务器推送（Server Push）**：服务器可以主动向客户端发送资源，而不必等待客户端的明确请求，这可以进一步提高页面加载效率。

总的来说，HTTP/1.1 主要依赖于文本基础的消息格式和持久连接来提高效率，而 HTTP/2 引入了二进制帧、多路复用和头部压缩等技术，大大提高了数据传输的效率和性能。

## 3 pickle 与 自定义界符的格式

### 掌握 pickle 中的封帧方法

`pickle` 是 Python 的一个模块，用于将 Python 对象序列化为字节流，这可以用于文件存储或通过网络传输。在使用 `pickle` 时，封帧方法不同于传统的网络封帧技术，因为它是针对 Python 对象的序列化和反序列化。下面是关于 `pickle` 封帧方法的一些要点：

1. **序列化（Serialization）**：

   - 当使用 `pickle` 对对象进行序列化时，它会将对象转换成一个字节流。这个字节流包含了重建该对象所需的所有信息。

2. **反序列化（Deserialization）**：

   - 反序列化是序列化的逆过程。它将 `pickle` 生成的字节流转换回原来的 Python 对象。

3. **封帧机制**：

   - `pickle` 使用的封帧机制是内置的，它自动处理所需的所有细节，以确保字节流可以被正确地序列化和反序列化。
   - 序列化的数据包含了对象类型、结构和内容的信息。`pickle` 会保存足够的元数据，以确保反序列化时能够准确地重建对象。

4. **安全性**：

   - 需要注意的是，从不受信任的源反序列化数据可能是不安全的。`pickle` 不是加密或压缩的形式，因此它序列化的数据应该只在受信任的内部使用。

5. **使用场景**：
   - `pickle` 主要用于 Python 对象的持久化存储或在信任的环境中的 Python 对象传输。

在实际应用中，如果需要通过网络发送 `pickle` 序列化的数据，可能需要在更低的网络层（如 TCP）上实现适当的封帧技术，以确保数据的完整性和正确分界。例如，可以在发送 `pickle` 数据前添加长度前缀，或者在数据的开始和结束处添加特定的界符。这样的处理确保了接收方能够正确地从网络流中提取和反序列化 `pickle` 数据。

## 4 XML 与 JSON

### 了解 XML 与 JSON 的基本特点与适用领域

XML（可扩展标记语言）和 JSON（JavaScript 对象表示法）都是常用的数据交换格式，但它们在结构、语法和使用场景上有一些显著的不同。让我们来看看它们各自的特点和适用领域。

### XML 的特点和适用领域：

1. **特点**：

   - XML 是一种标记语言，非常适合复杂的文档结构，如带有多层嵌套和属性的数据。
   - 它是自描述性的，意味着标签通常描述了数据的内容。
   - 支持命名空间，适合在多种不同类型的数据需要集成在一起的情况下使用。
   - 可以通过 XSD（XML Schema Definition）定义严格的结构，也支持通过 XSLT（Extensible Stylesheet Language Transformations）进行转换。

2. **适用领域**：
   - 由于其复杂的文档处理能力，XML 常用于企业级应用，如 Web 服务和配置文件。
   - 在需要长期数据存储和文档可读性的场合，XML 是一个不错的选择。
   - 在需要强数据验证和结构定义的系统中，如电子政务和银行系统。

### JSON 的特点和适用领域：

1. **特点**：

   - JSON 是一种轻量级的数据交换格式，以易于阅读和编写的方式呈现数据，同时也易于机器解析和生成。
   - 它基于 JavaScript 的对象和数组，结构清晰简单。
   - 不支持注释，结构比 XML 简单，一般不用于表示复杂的层次数据结构。
   - 传输效率高，尤其是在网络传输中，由于格式简单，解析速度快。

2. **适用领域**：
   - JSON 非常适合 Web 应用程序，特别是在使用 JavaScript 的前端框架和库时。
   - 由于其轻量级特性，它是移动应用和微服务架构的理想选择。
   - 在需要快速交互和数据更新的实时应用程序中，如在线游戏和聊天应用。

总的来说，XML 适合于需要严格文档结构和扩展性的复杂应用，而 JSON 则在需要高效数据交换和简单结构的现代网络应用中更受欢迎。选择哪种格式取决于具体的应用需求和上下文环境。

## 5 压缩

理解“数据在网络中传输所需要的时间通常远远多于 CPU 准备数据所用的时间”,结合带宽的发展速度和 CPU 的发展速度来思考
